/**
 * #redisapi.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";
import { Empty } from "../../../google/protobuf/empty.js";
import { BytesValue, DoubleValue, Int64Value, StringValue } from "../../../google/protobuf/wrappers.js";
import { messageTypeRegistry } from "../../../typeRegistry.js";
/**
 * This key scope determines the key namespacing in Redis storage
 * By default, all keys in Redis are namespaced to an installation
 * Global redis enables apps to persist and access state across subreddit installations
 * Default key format - installation:app:custom-key
 * Global redis key format - global:app:custom-key
 */
export var RedisKeyScope;
(function (RedisKeyScope) {
    RedisKeyScope[RedisKeyScope["INSTALLATION"] = 0] = "INSTALLATION";
    RedisKeyScope[RedisKeyScope["GLOBAL"] = 1] = "GLOBAL";
    RedisKeyScope[RedisKeyScope["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RedisKeyScope || (RedisKeyScope = {}));
export function redisKeyScopeFromJSON(object) {
    switch (object) {
        case 0:
        case "INSTALLATION":
            return RedisKeyScope.INSTALLATION;
        case 1:
        case "GLOBAL":
            return RedisKeyScope.GLOBAL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return RedisKeyScope.UNRECOGNIZED;
    }
}
export function redisKeyScopeToJSON(object) {
    switch (object) {
        case RedisKeyScope.INSTALLATION:
            return 0;
        case RedisKeyScope.GLOBAL:
            return 1;
        case RedisKeyScope.UNRECOGNIZED:
        default:
            return -1;
    }
}
export var BitfieldOverflowBehavior;
(function (BitfieldOverflowBehavior) {
    BitfieldOverflowBehavior[BitfieldOverflowBehavior["BITFIELD_OVERFLOW_BEHAVIOR_UNSPECIFIED"] = 0] = "BITFIELD_OVERFLOW_BEHAVIOR_UNSPECIFIED";
    BitfieldOverflowBehavior[BitfieldOverflowBehavior["BITFIELD_OVERFLOW_BEHAVIOR_WRAP"] = 1] = "BITFIELD_OVERFLOW_BEHAVIOR_WRAP";
    BitfieldOverflowBehavior[BitfieldOverflowBehavior["BITFIELD_OVERFLOW_BEHAVIOR_SAT"] = 2] = "BITFIELD_OVERFLOW_BEHAVIOR_SAT";
    BitfieldOverflowBehavior[BitfieldOverflowBehavior["BITFIELD_OVERFLOW_BEHAVIOR_FAIL"] = 3] = "BITFIELD_OVERFLOW_BEHAVIOR_FAIL";
    BitfieldOverflowBehavior[BitfieldOverflowBehavior["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BitfieldOverflowBehavior || (BitfieldOverflowBehavior = {}));
export function bitfieldOverflowBehaviorFromJSON(object) {
    switch (object) {
        case 0:
        case "BITFIELD_OVERFLOW_BEHAVIOR_UNSPECIFIED":
            return BitfieldOverflowBehavior.BITFIELD_OVERFLOW_BEHAVIOR_UNSPECIFIED;
        case 1:
        case "BITFIELD_OVERFLOW_BEHAVIOR_WRAP":
            return BitfieldOverflowBehavior.BITFIELD_OVERFLOW_BEHAVIOR_WRAP;
        case 2:
        case "BITFIELD_OVERFLOW_BEHAVIOR_SAT":
            return BitfieldOverflowBehavior.BITFIELD_OVERFLOW_BEHAVIOR_SAT;
        case 3:
        case "BITFIELD_OVERFLOW_BEHAVIOR_FAIL":
            return BitfieldOverflowBehavior.BITFIELD_OVERFLOW_BEHAVIOR_FAIL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return BitfieldOverflowBehavior.UNRECOGNIZED;
    }
}
export function bitfieldOverflowBehaviorToJSON(object) {
    switch (object) {
        case BitfieldOverflowBehavior.BITFIELD_OVERFLOW_BEHAVIOR_UNSPECIFIED:
            return 0;
        case BitfieldOverflowBehavior.BITFIELD_OVERFLOW_BEHAVIOR_WRAP:
            return 1;
        case BitfieldOverflowBehavior.BITFIELD_OVERFLOW_BEHAVIOR_SAT:
            return 2;
        case BitfieldOverflowBehavior.BITFIELD_OVERFLOW_BEHAVIOR_FAIL:
            return 3;
        case BitfieldOverflowBehavior.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseTransactionResponses() {
    return { response: [] };
}
export const TransactionResponses = {
    $type: "devvit.plugin.redis.TransactionResponses",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.response) {
            TransactionResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransactionResponses();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.response.push(TransactionResponse.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            response: globalThis.Array.isArray(object?.response)
                ? object.response.map((e) => TransactionResponse.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.response?.length) {
            obj.response = message.response.map((e) => TransactionResponse.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return TransactionResponses.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransactionResponses();
        message.response = object.response?.map((e) => TransactionResponse.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(TransactionResponses.$type, TransactionResponses);
function createBaseTransactionResponse() {
    return { str: undefined, nil: undefined, num: undefined, members: undefined, values: undefined, dbl: undefined };
}
export const TransactionResponse = {
    $type: "devvit.plugin.redis.TransactionResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.str !== undefined) {
            StringValue.encode({ value: message.str }, writer.uint32(10).fork()).ldelim();
        }
        if (message.nil !== undefined) {
            Empty.encode(message.nil, writer.uint32(18).fork()).ldelim();
        }
        if (message.num !== undefined) {
            Int64Value.encode({ value: message.num }, writer.uint32(26).fork()).ldelim();
        }
        if (message.members !== undefined) {
            ZMembers.encode(message.members, writer.uint32(34).fork()).ldelim();
        }
        if (message.values !== undefined) {
            RedisValues.encode(message.values, writer.uint32(42).fork()).ldelim();
        }
        if (message.dbl !== undefined) {
            DoubleValue.encode({ value: message.dbl }, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransactionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.str = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.nil = Empty.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.num = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.members = ZMembers.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.values = RedisValues.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.dbl = DoubleValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            str: isSet(object.str) ? String(object.str) : undefined,
            nil: isSet(object.nil) ? Empty.fromJSON(object.nil) : undefined,
            num: isSet(object.num) ? Number(object.num) : undefined,
            members: isSet(object.members) ? ZMembers.fromJSON(object.members) : undefined,
            values: isSet(object.values) ? RedisValues.fromJSON(object.values) : undefined,
            dbl: isSet(object.dbl) ? Number(object.dbl) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.str !== undefined) {
            obj.str = message.str;
        }
        if (message.nil !== undefined) {
            obj.nil = Empty.toJSON(message.nil);
        }
        if (message.num !== undefined) {
            obj.num = message.num;
        }
        if (message.members !== undefined) {
            obj.members = ZMembers.toJSON(message.members);
        }
        if (message.values !== undefined) {
            obj.values = RedisValues.toJSON(message.values);
        }
        if (message.dbl !== undefined) {
            obj.dbl = message.dbl;
        }
        return obj;
    },
    create(base) {
        return TransactionResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransactionResponse();
        message.str = object.str ?? undefined;
        message.nil = (object.nil !== undefined && object.nil !== null) ? Empty.fromPartial(object.nil) : undefined;
        message.num = object.num ?? undefined;
        message.members = (object.members !== undefined && object.members !== null)
            ? ZMembers.fromPartial(object.members)
            : undefined;
        message.values = (object.values !== undefined && object.values !== null)
            ? RedisValues.fromPartial(object.values)
            : undefined;
        message.dbl = object.dbl ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(TransactionResponse.$type, TransactionResponse);
function createBaseZRangeRequest() {
    return {
        key: undefined,
        start: "",
        stop: "",
        byScore: false,
        byLex: false,
        rev: false,
        offset: 0,
        count: 0,
        scope: undefined,
    };
}
export const ZRangeRequest = {
    $type: "devvit.plugin.redis.ZRangeRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.start !== "") {
            writer.uint32(18).string(message.start);
        }
        if (message.stop !== "") {
            writer.uint32(26).string(message.stop);
        }
        if (message.byScore !== false) {
            writer.uint32(32).bool(message.byScore);
        }
        if (message.byLex !== false) {
            writer.uint32(40).bool(message.byLex);
        }
        if (message.rev !== false) {
            writer.uint32(48).bool(message.rev);
        }
        if (message.offset !== 0) {
            writer.uint32(56).int32(message.offset);
        }
        if (message.count !== 0) {
            writer.uint32(64).int32(message.count);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZRangeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.start = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.stop = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.byScore = reader.bool();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.byLex = reader.bool();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.rev = reader.bool();
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.offset = reader.int32();
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.count = reader.int32();
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            start: isSet(object.start) ? globalThis.String(object.start) : "",
            stop: isSet(object.stop) ? globalThis.String(object.stop) : "",
            byScore: isSet(object.byScore) ? globalThis.Boolean(object.byScore) : false,
            byLex: isSet(object.byLex) ? globalThis.Boolean(object.byLex) : false,
            rev: isSet(object.rev) ? globalThis.Boolean(object.rev) : false,
            offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
            count: isSet(object.count) ? globalThis.Number(object.count) : 0,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== undefined) {
            obj.key = KeyRequest.toJSON(message.key);
        }
        if (message.start !== "") {
            obj.start = message.start;
        }
        if (message.stop !== "") {
            obj.stop = message.stop;
        }
        if (message.byScore !== false) {
            obj.byScore = message.byScore;
        }
        if (message.byLex !== false) {
            obj.byLex = message.byLex;
        }
        if (message.rev !== false) {
            obj.rev = message.rev;
        }
        if (message.offset !== 0) {
            obj.offset = Math.round(message.offset);
        }
        if (message.count !== 0) {
            obj.count = Math.round(message.count);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return ZRangeRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseZRangeRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.start = object.start ?? "";
        message.stop = object.stop ?? "";
        message.byScore = object.byScore ?? false;
        message.byLex = object.byLex ?? false;
        message.rev = object.rev ?? false;
        message.offset = object.offset ?? 0;
        message.count = object.count ?? 0;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ZRangeRequest.$type, ZRangeRequest);
function createBaseZRangeByLexRequest() {
    return { key: undefined, min: "", max: "", scope: undefined };
}
export const ZRangeByLexRequest = {
    $type: "devvit.plugin.redis.ZRangeByLexRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.min !== "") {
            writer.uint32(18).string(message.min);
        }
        if (message.max !== "") {
            writer.uint32(26).string(message.max);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZRangeByLexRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.min = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.max = reader.string();
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            min: isSet(object.min) ? globalThis.String(object.min) : "",
            max: isSet(object.max) ? globalThis.String(object.max) : "",
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== undefined) {
            obj.key = KeyRequest.toJSON(message.key);
        }
        if (message.min !== "") {
            obj.min = message.min;
        }
        if (message.max !== "") {
            obj.max = message.max;
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return ZRangeByLexRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseZRangeByLexRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.min = object.min ?? "";
        message.max = object.max ?? "";
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ZRangeByLexRequest.$type, ZRangeByLexRequest);
function createBaseZRangeByScoreRequest() {
    return { key: undefined, min: 0, max: 0, withScores: false, scope: undefined };
}
export const ZRangeByScoreRequest = {
    $type: "devvit.plugin.redis.ZRangeByScoreRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.min !== 0) {
            writer.uint32(17).double(message.min);
        }
        if (message.max !== 0) {
            writer.uint32(25).double(message.max);
        }
        if (message.withScores !== false) {
            writer.uint32(32).bool(message.withScores);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZRangeByScoreRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 17) {
                        break;
                    }
                    message.min = reader.double();
                    continue;
                case 3:
                    if (tag !== 25) {
                        break;
                    }
                    message.max = reader.double();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.withScores = reader.bool();
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            min: isSet(object.min) ? globalThis.Number(object.min) : 0,
            max: isSet(object.max) ? globalThis.Number(object.max) : 0,
            withScores: isSet(object.withScores) ? globalThis.Boolean(object.withScores) : false,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== undefined) {
            obj.key = KeyRequest.toJSON(message.key);
        }
        if (message.min !== 0) {
            obj.min = message.min;
        }
        if (message.max !== 0) {
            obj.max = message.max;
        }
        if (message.withScores !== false) {
            obj.withScores = message.withScores;
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return ZRangeByScoreRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseZRangeByScoreRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.min = object.min ?? 0;
        message.max = object.max ?? 0;
        message.withScores = object.withScores ?? false;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ZRangeByScoreRequest.$type, ZRangeByScoreRequest);
function createBaseZRemRequest() {
    return { key: undefined, members: [], scope: undefined };
}
export const ZRemRequest = {
    $type: "devvit.plugin.redis.ZRemRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.members) {
            writer.uint32(18).string(v);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZRemRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.members.push(reader.string());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            members: globalThis.Array.isArray(object?.members) ? object.members.map((e) => globalThis.String(e)) : [],
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== undefined) {
            obj.key = KeyRequest.toJSON(message.key);
        }
        if (message.members?.length) {
            obj.members = message.members;
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return ZRemRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseZRemRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.members = object.members?.map((e) => e) || [];
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ZRemRequest.$type, ZRemRequest);
function createBaseZRemRangeByLexRequest() {
    return { key: undefined, min: "", max: "", scope: undefined };
}
export const ZRemRangeByLexRequest = {
    $type: "devvit.plugin.redis.ZRemRangeByLexRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.min !== "") {
            writer.uint32(18).string(message.min);
        }
        if (message.max !== "") {
            writer.uint32(26).string(message.max);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZRemRangeByLexRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.min = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.max = reader.string();
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            min: isSet(object.min) ? globalThis.String(object.min) : "",
            max: isSet(object.max) ? globalThis.String(object.max) : "",
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== undefined) {
            obj.key = KeyRequest.toJSON(message.key);
        }
        if (message.min !== "") {
            obj.min = message.min;
        }
        if (message.max !== "") {
            obj.max = message.max;
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return ZRemRangeByLexRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseZRemRangeByLexRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.min = object.min ?? "";
        message.max = object.max ?? "";
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ZRemRangeByLexRequest.$type, ZRemRangeByLexRequest);
function createBaseZRemRangeByRankRequest() {
    return { key: undefined, start: 0, stop: 0, scope: undefined };
}
export const ZRemRangeByRankRequest = {
    $type: "devvit.plugin.redis.ZRemRangeByRankRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.start !== 0) {
            writer.uint32(16).int32(message.start);
        }
        if (message.stop !== 0) {
            writer.uint32(24).int32(message.stop);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZRemRangeByRankRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.start = reader.int32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.stop = reader.int32();
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            start: isSet(object.start) ? globalThis.Number(object.start) : 0,
            stop: isSet(object.stop) ? globalThis.Number(object.stop) : 0,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== undefined) {
            obj.key = KeyRequest.toJSON(message.key);
        }
        if (message.start !== 0) {
            obj.start = Math.round(message.start);
        }
        if (message.stop !== 0) {
            obj.stop = Math.round(message.stop);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return ZRemRangeByRankRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseZRemRangeByRankRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.start = object.start ?? 0;
        message.stop = object.stop ?? 0;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ZRemRangeByRankRequest.$type, ZRemRangeByRankRequest);
function createBaseZRemRangeByScoreRequest() {
    return { key: undefined, min: 0, max: 0, scope: undefined };
}
export const ZRemRangeByScoreRequest = {
    $type: "devvit.plugin.redis.ZRemRangeByScoreRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.min !== 0) {
            writer.uint32(17).double(message.min);
        }
        if (message.max !== 0) {
            writer.uint32(25).double(message.max);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZRemRangeByScoreRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 17) {
                        break;
                    }
                    message.min = reader.double();
                    continue;
                case 3:
                    if (tag !== 25) {
                        break;
                    }
                    message.max = reader.double();
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            min: isSet(object.min) ? globalThis.Number(object.min) : 0,
            max: isSet(object.max) ? globalThis.Number(object.max) : 0,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== undefined) {
            obj.key = KeyRequest.toJSON(message.key);
        }
        if (message.min !== 0) {
            obj.min = message.min;
        }
        if (message.max !== 0) {
            obj.max = message.max;
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return ZRemRangeByScoreRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseZRemRangeByScoreRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.min = object.min ?? 0;
        message.max = object.max ?? 0;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ZRemRangeByScoreRequest.$type, ZRemRangeByScoreRequest);
function createBaseZScoreRequest() {
    return { key: undefined, member: "", scope: undefined };
}
export const ZScoreRequest = {
    $type: "devvit.plugin.redis.ZScoreRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.member !== "") {
            writer.uint32(18).string(message.member);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZScoreRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.member = reader.string();
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            member: isSet(object.member) ? globalThis.String(object.member) : "",
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== undefined) {
            obj.key = KeyRequest.toJSON(message.key);
        }
        if (message.member !== "") {
            obj.member = message.member;
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return ZScoreRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseZScoreRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.member = object.member ?? "";
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ZScoreRequest.$type, ZScoreRequest);
function createBaseZRankRequest() {
    return { key: undefined, member: "", scope: undefined };
}
export const ZRankRequest = {
    $type: "devvit.plugin.redis.ZRankRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.member !== "") {
            writer.uint32(18).string(message.member);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZRankRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.member = reader.string();
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            member: isSet(object.member) ? globalThis.String(object.member) : "",
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== undefined) {
            obj.key = KeyRequest.toJSON(message.key);
        }
        if (message.member !== "") {
            obj.member = message.member;
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return ZRankRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseZRankRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.member = object.member ?? "";
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ZRankRequest.$type, ZRankRequest);
function createBaseRedisRankScore() {
    return { rank: 0, score: 0 };
}
export const RedisRankScore = {
    $type: "devvit.plugin.redis.RedisRankScore",
    encode(message, writer = _m0.Writer.create()) {
        if (message.rank !== 0) {
            writer.uint32(8).int64(message.rank);
        }
        if (message.score !== 0) {
            writer.uint32(17).double(message.score);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedisRankScore();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.rank = longToNumber(reader.int64());
                    continue;
                case 2:
                    if (tag !== 17) {
                        break;
                    }
                    message.score = reader.double();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
            score: isSet(object.score) ? globalThis.Number(object.score) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.rank !== 0) {
            obj.rank = Math.round(message.rank);
        }
        if (message.score !== 0) {
            obj.score = message.score;
        }
        return obj;
    },
    create(base) {
        return RedisRankScore.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRedisRankScore();
        message.rank = object.rank ?? 0;
        message.score = object.score ?? 0;
        return message;
    },
};
messageTypeRegistry.set(RedisRankScore.$type, RedisRankScore);
function createBaseZIncrByRequest() {
    return { key: "", member: "", value: 0, transactionId: undefined, scope: undefined };
}
export const ZIncrByRequest = {
    $type: "devvit.plugin.redis.ZIncrByRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.member !== "") {
            writer.uint32(18).string(message.member);
        }
        if (message.value !== 0) {
            writer.uint32(25).double(message.value);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(50).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZIncrByRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.member = reader.string();
                    continue;
                case 3:
                    if (tag !== 25) {
                        break;
                    }
                    message.value = reader.double();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            member: isSet(object.member) ? globalThis.String(object.member) : "",
            value: isSet(object.value) ? globalThis.Number(object.value) : 0,
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.member !== "") {
            obj.member = message.member;
        }
        if (message.value !== 0) {
            obj.value = message.value;
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return ZIncrByRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseZIncrByRequest();
        message.key = object.key ?? "";
        message.member = object.member ?? "";
        message.value = object.value ?? 0;
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ZIncrByRequest.$type, ZIncrByRequest);
function createBaseKeyRequest() {
    return { key: "", transactionId: undefined, scope: undefined };
}
export const KeyRequest = {
    $type: "devvit.plugin.redis.KeyRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(18).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return KeyRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseKeyRequest();
        message.key = object.key ?? "";
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(KeyRequest.$type, KeyRequest);
function createBaseIncrByRequest() {
    return { key: "", value: 0, transactionId: undefined, scope: undefined };
}
export const IncrByRequest = {
    $type: "devvit.plugin.redis.IncrByRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).int64(message.value);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(50).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIncrByRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.value = longToNumber(reader.int64());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.Number(object.value) : 0,
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== 0) {
            obj.value = Math.round(message.value);
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return IncrByRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseIncrByRequest();
        message.key = object.key ?? "";
        message.value = object.value ?? 0;
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(IncrByRequest.$type, IncrByRequest);
function createBaseSetRequest() {
    return { key: "", value: "", expiration: 0, nx: false, xx: false, transactionId: undefined, scope: undefined };
}
export const SetRequest = {
    $type: "devvit.plugin.redis.SetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        if (message.expiration !== 0) {
            writer.uint32(24).int64(message.expiration);
        }
        if (message.nx !== false) {
            writer.uint32(32).bool(message.nx);
        }
        if (message.xx !== false) {
            writer.uint32(40).bool(message.xx);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(50).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.expiration = longToNumber(reader.int64());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.nx = reader.bool();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.xx = reader.bool();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
            expiration: isSet(object.expiration) ? globalThis.Number(object.expiration) : 0,
            nx: isSet(object.nx) ? globalThis.Boolean(object.nx) : false,
            xx: isSet(object.xx) ? globalThis.Boolean(object.xx) : false,
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        if (message.expiration !== 0) {
            obj.expiration = Math.round(message.expiration);
        }
        if (message.nx !== false) {
            obj.nx = message.nx;
        }
        if (message.xx !== false) {
            obj.xx = message.xx;
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return SetRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSetRequest();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        message.expiration = object.expiration ?? 0;
        message.nx = object.nx ?? false;
        message.xx = object.xx ?? false;
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(SetRequest.$type, SetRequest);
function createBaseKeyRangeRequest() {
    return { key: "", start: 0, end: 0, transactionId: undefined, scope: undefined };
}
export const KeyRangeRequest = {
    $type: "devvit.plugin.redis.KeyRangeRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.start !== 0) {
            writer.uint32(16).int32(message.start);
        }
        if (message.end !== 0) {
            writer.uint32(24).int32(message.end);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(34).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeyRangeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.start = reader.int32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.end = reader.int32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            start: isSet(object.start) ? globalThis.Number(object.start) : 0,
            end: isSet(object.end) ? globalThis.Number(object.end) : 0,
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.start !== 0) {
            obj.start = Math.round(message.start);
        }
        if (message.end !== 0) {
            obj.end = Math.round(message.end);
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return KeyRangeRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseKeyRangeRequest();
        message.key = object.key ?? "";
        message.start = object.start ?? 0;
        message.end = object.end ?? 0;
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(KeyRangeRequest.$type, KeyRangeRequest);
function createBaseSetRangeRequest() {
    return { key: "", offset: 0, value: "", transactionId: undefined, scope: undefined };
}
export const SetRangeRequest = {
    $type: "devvit.plugin.redis.SetRangeRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.offset !== 0) {
            writer.uint32(16).int32(message.offset);
        }
        if (message.value !== "") {
            writer.uint32(26).string(message.value);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(34).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetRangeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.offset = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
            value: isSet(object.value) ? globalThis.String(object.value) : "",
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.offset !== 0) {
            obj.offset = Math.round(message.offset);
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return SetRangeRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSetRangeRequest();
        message.key = object.key ?? "";
        message.offset = object.offset ?? 0;
        message.value = object.value ?? "";
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(SetRangeRequest.$type, SetRangeRequest);
function createBaseKeysRequest() {
    return { keys: [], transactionId: undefined, scope: undefined };
}
export const KeysRequest = {
    $type: "devvit.plugin.redis.KeysRequest",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.keys) {
            writer.uint32(10).string(v);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(18).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeysRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.keys.push(reader.string());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e) => globalThis.String(e)) : [],
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.keys?.length) {
            obj.keys = message.keys;
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return KeysRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseKeysRequest();
        message.keys = object.keys?.map((e) => e) || [];
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(KeysRequest.$type, KeysRequest);
function createBaseKeysResponse() {
    return { keys: [] };
}
export const KeysResponse = {
    $type: "devvit.plugin.redis.KeysResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.keys) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeysResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.keys.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e) => globalThis.String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.keys?.length) {
            obj.keys = message.keys;
        }
        return obj;
    },
    create(base) {
        return KeysResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseKeysResponse();
        message.keys = object.keys?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set(KeysResponse.$type, KeysResponse);
function createBaseExistsResponse() {
    return { existingKeys: 0 };
}
export const ExistsResponse = {
    $type: "devvit.plugin.redis.ExistsResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.existingKeys !== 0) {
            writer.uint32(8).int64(message.existingKeys);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExistsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.existingKeys = longToNumber(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { existingKeys: isSet(object.existingKeys) ? globalThis.Number(object.existingKeys) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.existingKeys !== 0) {
            obj.existingKeys = Math.round(message.existingKeys);
        }
        return obj;
    },
    create(base) {
        return ExistsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseExistsResponse();
        message.existingKeys = object.existingKeys ?? 0;
        return message;
    },
};
messageTypeRegistry.set(ExistsResponse.$type, ExistsResponse);
function createBaseHGetRequest() {
    return { key: "", field: "", transactionId: undefined, scope: undefined };
}
export const HGetRequest = {
    $type: "devvit.plugin.redis.HGetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.field !== "") {
            writer.uint32(18).string(message.field);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(26).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHGetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.field = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            field: isSet(object.field) ? globalThis.String(object.field) : "",
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.field !== "") {
            obj.field = message.field;
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return HGetRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHGetRequest();
        message.key = object.key ?? "";
        message.field = object.field ?? "";
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(HGetRequest.$type, HGetRequest);
function createBaseHMGetRequest() {
    return { key: "", fields: [], transactionId: undefined, scope: undefined };
}
export const HMGetRequest = {
    $type: "devvit.plugin.redis.HMGetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        for (const v of message.fields) {
            writer.uint32(18).string(v);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(26).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHMGetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.fields.push(reader.string());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e) => globalThis.String(e)) : [],
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.fields?.length) {
            obj.fields = message.fields;
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return HMGetRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHMGetRequest();
        message.key = object.key ?? "";
        message.fields = object.fields?.map((e) => e) || [];
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(HMGetRequest.$type, HMGetRequest);
function createBaseHSetRequest() {
    return { key: "", fv: [], transactionId: undefined, scope: undefined };
}
export const HSetRequest = {
    $type: "devvit.plugin.redis.HSetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        for (const v of message.fv) {
            RedisFieldValue.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(26).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHSetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.fv.push(RedisFieldValue.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            fv: globalThis.Array.isArray(object?.fv) ? object.fv.map((e) => RedisFieldValue.fromJSON(e)) : [],
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.fv?.length) {
            obj.fv = message.fv.map((e) => RedisFieldValue.toJSON(e));
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return HSetRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHSetRequest();
        message.key = object.key ?? "";
        message.fv = object.fv?.map((e) => RedisFieldValue.fromPartial(e)) || [];
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(HSetRequest.$type, HSetRequest);
function createBaseHSetNXResponse() {
    return { success: 0 };
}
export const HSetNXResponse = {
    $type: "devvit.plugin.redis.HSetNXResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.success !== 0) {
            writer.uint32(8).int64(message.success);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHSetNXResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.success = longToNumber(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { success: isSet(object.success) ? globalThis.Number(object.success) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.success !== 0) {
            obj.success = Math.round(message.success);
        }
        return obj;
    },
    create(base) {
        return HSetNXResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHSetNXResponse();
        message.success = object.success ?? 0;
        return message;
    },
};
messageTypeRegistry.set(HSetNXResponse.$type, HSetNXResponse);
function createBaseHDelRequest() {
    return { key: "", fields: [], transactionId: undefined, scope: undefined };
}
export const HDelRequest = {
    $type: "devvit.plugin.redis.HDelRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        for (const v of message.fields) {
            writer.uint32(18).string(v);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(26).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHDelRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.fields.push(reader.string());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e) => globalThis.String(e)) : [],
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.fields?.length) {
            obj.fields = message.fields;
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return HDelRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHDelRequest();
        message.key = object.key ?? "";
        message.fields = object.fields?.map((e) => e) || [];
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(HDelRequest.$type, HDelRequest);
function createBaseHScanRequest() {
    return { key: "", cursor: 0, pattern: undefined, count: undefined, transactionId: undefined, scope: undefined };
}
export const HScanRequest = {
    $type: "devvit.plugin.redis.HScanRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.cursor !== 0) {
            writer.uint32(16).uint64(message.cursor);
        }
        if (message.pattern !== undefined) {
            writer.uint32(26).string(message.pattern);
        }
        if (message.count !== undefined) {
            writer.uint32(32).int64(message.count);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(42).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHScanRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.cursor = longToNumber(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.pattern = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.count = longToNumber(reader.int64());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            cursor: isSet(object.cursor) ? globalThis.Number(object.cursor) : 0,
            pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : undefined,
            count: isSet(object.count) ? globalThis.Number(object.count) : undefined,
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.cursor !== 0) {
            obj.cursor = Math.round(message.cursor);
        }
        if (message.pattern !== undefined) {
            obj.pattern = message.pattern;
        }
        if (message.count !== undefined) {
            obj.count = Math.round(message.count);
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return HScanRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHScanRequest();
        message.key = object.key ?? "";
        message.cursor = object.cursor ?? 0;
        message.pattern = object.pattern ?? undefined;
        message.count = object.count ?? undefined;
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(HScanRequest.$type, HScanRequest);
function createBaseHScanResponse() {
    return { cursor: 0, fieldValues: [] };
}
export const HScanResponse = {
    $type: "devvit.plugin.redis.HScanResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.cursor !== 0) {
            writer.uint32(8).uint64(message.cursor);
        }
        for (const v of message.fieldValues) {
            RedisFieldValue.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHScanResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.cursor = longToNumber(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.fieldValues.push(RedisFieldValue.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            cursor: isSet(object.cursor) ? globalThis.Number(object.cursor) : 0,
            fieldValues: globalThis.Array.isArray(object?.fieldValues)
                ? object.fieldValues.map((e) => RedisFieldValue.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.cursor !== 0) {
            obj.cursor = Math.round(message.cursor);
        }
        if (message.fieldValues?.length) {
            obj.fieldValues = message.fieldValues.map((e) => RedisFieldValue.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return HScanResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHScanResponse();
        message.cursor = object.cursor ?? 0;
        message.fieldValues = object.fieldValues?.map((e) => RedisFieldValue.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(HScanResponse.$type, HScanResponse);
function createBaseHIncrByRequest() {
    return { key: "", field: "", value: 0, transactionId: undefined, scope: undefined };
}
export const HIncrByRequest = {
    $type: "devvit.plugin.redis.HIncrByRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.field !== "") {
            writer.uint32(18).string(message.field);
        }
        if (message.value !== 0) {
            writer.uint32(24).int64(message.value);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(50).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHIncrByRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.field = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.value = longToNumber(reader.int64());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            field: isSet(object.field) ? globalThis.String(object.field) : "",
            value: isSet(object.value) ? globalThis.Number(object.value) : 0,
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.field !== "") {
            obj.field = message.field;
        }
        if (message.value !== 0) {
            obj.value = Math.round(message.value);
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return HIncrByRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHIncrByRequest();
        message.key = object.key ?? "";
        message.field = object.field ?? "";
        message.value = object.value ?? 0;
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(HIncrByRequest.$type, HIncrByRequest);
function createBaseRedisFieldValue() {
    return { field: "", value: "" };
}
export const RedisFieldValue = {
    $type: "devvit.plugin.redis.RedisFieldValue",
    encode(message, writer = _m0.Writer.create()) {
        if (message.field !== "") {
            writer.uint32(10).string(message.field);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedisFieldValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.field = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            field: isSet(object.field) ? globalThis.String(object.field) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.field !== "") {
            obj.field = message.field;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return RedisFieldValue.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRedisFieldValue();
        message.field = object.field ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
messageTypeRegistry.set(RedisFieldValue.$type, RedisFieldValue);
function createBaseRedisFieldValues() {
    return { fieldValues: {} };
}
export const RedisFieldValues = {
    $type: "devvit.plugin.redis.RedisFieldValues",
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.fieldValues).forEach(([key, value]) => {
            RedisFieldValues_FieldValuesEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedisFieldValues();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = RedisFieldValues_FieldValuesEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.fieldValues[entry1.key] = entry1.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            fieldValues: isObject(object.fieldValues)
                ? Object.entries(object.fieldValues).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.fieldValues) {
            const entries = Object.entries(message.fieldValues);
            if (entries.length > 0) {
                obj.fieldValues = {};
                entries.forEach(([k, v]) => {
                    obj.fieldValues[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return RedisFieldValues.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRedisFieldValues();
        message.fieldValues = Object.entries(object.fieldValues ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set(RedisFieldValues.$type, RedisFieldValues);
function createBaseRedisFieldValues_FieldValuesEntry() {
    return { key: "", value: "" };
}
export const RedisFieldValues_FieldValuesEntry = {
    $type: "devvit.plugin.redis.RedisFieldValues.FieldValuesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedisFieldValues_FieldValuesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return RedisFieldValues_FieldValuesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRedisFieldValues_FieldValuesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
messageTypeRegistry.set(RedisFieldValues_FieldValuesEntry.$type, RedisFieldValues_FieldValuesEntry);
function createBaseKeyValuesRequest() {
    return { kv: [], transactionId: undefined, scope: undefined };
}
export const KeyValuesRequest = {
    $type: "devvit.plugin.redis.KeyValuesRequest",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.kv) {
            RedisKeyValue.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(18).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeyValuesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.kv.push(RedisKeyValue.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            kv: globalThis.Array.isArray(object?.kv) ? object.kv.map((e) => RedisKeyValue.fromJSON(e)) : [],
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.kv?.length) {
            obj.kv = message.kv.map((e) => RedisKeyValue.toJSON(e));
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return KeyValuesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseKeyValuesRequest();
        message.kv = object.kv?.map((e) => RedisKeyValue.fromPartial(e)) || [];
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(KeyValuesRequest.$type, KeyValuesRequest);
function createBaseRedisKeyValue() {
    return { key: "", value: "" };
}
export const RedisKeyValue = {
    $type: "devvit.plugin.redis.RedisKeyValue",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedisKeyValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return RedisKeyValue.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRedisKeyValue();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
messageTypeRegistry.set(RedisKeyValue.$type, RedisKeyValue);
function createBaseRedisValues() {
    return { values: [] };
}
export const RedisValues = {
    $type: "devvit.plugin.redis.RedisValues",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.values) {
            StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedisValues();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.values.push(StringValue.decode(reader, reader.uint32()).value);
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { values: globalThis.Array.isArray(object?.values) ? object.values.map((e) => String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.values?.length) {
            obj.values = message.values;
        }
        return obj;
    },
    create(base) {
        return RedisValues.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRedisValues();
        message.values = object.values?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set(RedisValues.$type, RedisValues);
function createBaseExpireRequest() {
    return { key: "", seconds: 0, transactionId: undefined, scope: undefined };
}
export const ExpireRequest = {
    $type: "devvit.plugin.redis.ExpireRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.seconds !== 0) {
            writer.uint32(16).int32(message.seconds);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(26).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExpireRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.seconds = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            seconds: isSet(object.seconds) ? globalThis.Number(object.seconds) : 0,
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.seconds !== 0) {
            obj.seconds = Math.round(message.seconds);
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return ExpireRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseExpireRequest();
        message.key = object.key ?? "";
        message.seconds = object.seconds ?? 0;
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ExpireRequest.$type, ExpireRequest);
function createBaseZAddRequest() {
    return { key: "", members: [], transactionId: undefined, scope: undefined };
}
export const ZAddRequest = {
    $type: "devvit.plugin.redis.ZAddRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        for (const v of message.members) {
            ZMember.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(26).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZAddRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.members.push(ZMember.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            members: globalThis.Array.isArray(object?.members) ? object.members.map((e) => ZMember.fromJSON(e)) : [],
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.members?.length) {
            obj.members = message.members.map((e) => ZMember.toJSON(e));
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return ZAddRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseZAddRequest();
        message.key = object.key ?? "";
        message.members = object.members?.map((e) => ZMember.fromPartial(e)) || [];
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ZAddRequest.$type, ZAddRequest);
function createBaseZScanRequest() {
    return { key: "", cursor: 0, pattern: undefined, count: undefined, transactionId: undefined, scope: undefined };
}
export const ZScanRequest = {
    $type: "devvit.plugin.redis.ZScanRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.cursor !== 0) {
            writer.uint32(16).uint64(message.cursor);
        }
        if (message.pattern !== undefined) {
            writer.uint32(26).string(message.pattern);
        }
        if (message.count !== undefined) {
            writer.uint32(32).int64(message.count);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(42).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZScanRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.cursor = longToNumber(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.pattern = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.count = longToNumber(reader.int64());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            cursor: isSet(object.cursor) ? globalThis.Number(object.cursor) : 0,
            pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : undefined,
            count: isSet(object.count) ? globalThis.Number(object.count) : undefined,
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.cursor !== 0) {
            obj.cursor = Math.round(message.cursor);
        }
        if (message.pattern !== undefined) {
            obj.pattern = message.pattern;
        }
        if (message.count !== undefined) {
            obj.count = Math.round(message.count);
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return ZScanRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseZScanRequest();
        message.key = object.key ?? "";
        message.cursor = object.cursor ?? 0;
        message.pattern = object.pattern ?? undefined;
        message.count = object.count ?? undefined;
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ZScanRequest.$type, ZScanRequest);
function createBaseZScanResponse() {
    return { cursor: 0, members: [] };
}
export const ZScanResponse = {
    $type: "devvit.plugin.redis.ZScanResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.cursor !== 0) {
            writer.uint32(8).uint64(message.cursor);
        }
        for (const v of message.members) {
            ZMember.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZScanResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.cursor = longToNumber(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.members.push(ZMember.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            cursor: isSet(object.cursor) ? globalThis.Number(object.cursor) : 0,
            members: globalThis.Array.isArray(object?.members) ? object.members.map((e) => ZMember.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.cursor !== 0) {
            obj.cursor = Math.round(message.cursor);
        }
        if (message.members?.length) {
            obj.members = message.members.map((e) => ZMember.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return ZScanResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseZScanResponse();
        message.cursor = object.cursor ?? 0;
        message.members = object.members?.map((e) => ZMember.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(ZScanResponse.$type, ZScanResponse);
function createBaseZMembers() {
    return { members: [] };
}
export const ZMembers = {
    $type: "devvit.plugin.redis.ZMembers",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.members) {
            ZMember.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZMembers();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.members.push(ZMember.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            members: globalThis.Array.isArray(object?.members) ? object.members.map((e) => ZMember.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.members?.length) {
            obj.members = message.members.map((e) => ZMember.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return ZMembers.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseZMembers();
        message.members = object.members?.map((e) => ZMember.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(ZMembers.$type, ZMembers);
function createBaseZMember() {
    return { score: 0, member: "" };
}
export const ZMember = {
    $type: "devvit.plugin.redis.ZMember",
    encode(message, writer = _m0.Writer.create()) {
        if (message.score !== 0) {
            writer.uint32(9).double(message.score);
        }
        if (message.member !== "") {
            writer.uint32(18).string(message.member);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZMember();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 9) {
                        break;
                    }
                    message.score = reader.double();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.member = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            score: isSet(object.score) ? globalThis.Number(object.score) : 0,
            member: isSet(object.member) ? globalThis.String(object.member) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.score !== 0) {
            obj.score = message.score;
        }
        if (message.member !== "") {
            obj.member = message.member;
        }
        return obj;
    },
    create(base) {
        return ZMember.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseZMember();
        message.score = object.score ?? 0;
        message.member = object.member ?? "";
        return message;
    },
};
messageTypeRegistry.set(ZMember.$type, ZMember);
function createBaseTransactionId() {
    return { id: "" };
}
export const TransactionId = {
    $type: "devvit.plugin.redis.TransactionId",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransactionId();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        return obj;
    },
    create(base) {
        return TransactionId.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransactionId();
        message.id = object.id ?? "";
        return message;
    },
};
messageTypeRegistry.set(TransactionId.$type, TransactionId);
function createBaseWatchRequest() {
    return { transactionId: undefined, keys: [] };
}
export const WatchRequest = {
    $type: "devvit.plugin.redis.WatchRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.keys) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWatchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.keys.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.keys?.length) {
            obj.keys = message.keys;
        }
        return obj;
    },
    create(base) {
        return WatchRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWatchRequest();
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.keys = object.keys?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set(WatchRequest.$type, WatchRequest);
function createBaseBitfieldRequest() {
    return { key: "", commands: [], transactionId: undefined };
}
export const BitfieldRequest = {
    $type: "devvit.plugin.redis.BitfieldRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        for (const v of message.commands) {
            BitfieldCommand.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBitfieldRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.commands.push(BitfieldCommand.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            commands: globalThis.Array.isArray(object?.commands)
                ? object.commands.map((e) => BitfieldCommand.fromJSON(e))
                : [],
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.commands?.length) {
            obj.commands = message.commands.map((e) => BitfieldCommand.toJSON(e));
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        return obj;
    },
    create(base) {
        return BitfieldRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBitfieldRequest();
        message.key = object.key ?? "";
        message.commands = object.commands?.map((e) => BitfieldCommand.fromPartial(e)) || [];
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(BitfieldRequest.$type, BitfieldRequest);
function createBaseBitfieldCommand() {
    return { get: undefined, set: undefined, incrBy: undefined, overflow: undefined };
}
export const BitfieldCommand = {
    $type: "devvit.plugin.redis.BitfieldCommand",
    encode(message, writer = _m0.Writer.create()) {
        if (message.get !== undefined) {
            BitfieldGet.encode(message.get, writer.uint32(10).fork()).ldelim();
        }
        if (message.set !== undefined) {
            BitfieldSet.encode(message.set, writer.uint32(18).fork()).ldelim();
        }
        if (message.incrBy !== undefined) {
            BitfieldIncrBy.encode(message.incrBy, writer.uint32(26).fork()).ldelim();
        }
        if (message.overflow !== undefined) {
            BitfieldOverflow.encode(message.overflow, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBitfieldCommand();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.get = BitfieldGet.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.set = BitfieldSet.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.incrBy = BitfieldIncrBy.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.overflow = BitfieldOverflow.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            get: isSet(object.get) ? BitfieldGet.fromJSON(object.get) : undefined,
            set: isSet(object.set) ? BitfieldSet.fromJSON(object.set) : undefined,
            incrBy: isSet(object.incrBy) ? BitfieldIncrBy.fromJSON(object.incrBy) : undefined,
            overflow: isSet(object.overflow) ? BitfieldOverflow.fromJSON(object.overflow) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.get !== undefined) {
            obj.get = BitfieldGet.toJSON(message.get);
        }
        if (message.set !== undefined) {
            obj.set = BitfieldSet.toJSON(message.set);
        }
        if (message.incrBy !== undefined) {
            obj.incrBy = BitfieldIncrBy.toJSON(message.incrBy);
        }
        if (message.overflow !== undefined) {
            obj.overflow = BitfieldOverflow.toJSON(message.overflow);
        }
        return obj;
    },
    create(base) {
        return BitfieldCommand.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBitfieldCommand();
        message.get = (object.get !== undefined && object.get !== null) ? BitfieldGet.fromPartial(object.get) : undefined;
        message.set = (object.set !== undefined && object.set !== null) ? BitfieldSet.fromPartial(object.set) : undefined;
        message.incrBy = (object.incrBy !== undefined && object.incrBy !== null)
            ? BitfieldIncrBy.fromPartial(object.incrBy)
            : undefined;
        message.overflow = (object.overflow !== undefined && object.overflow !== null)
            ? BitfieldOverflow.fromPartial(object.overflow)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(BitfieldCommand.$type, BitfieldCommand);
function createBaseBitfieldGet() {
    return { encoding: "", offset: "" };
}
export const BitfieldGet = {
    $type: "devvit.plugin.redis.BitfieldGet",
    encode(message, writer = _m0.Writer.create()) {
        if (message.encoding !== "") {
            writer.uint32(10).string(message.encoding);
        }
        if (message.offset !== "") {
            writer.uint32(18).string(message.offset);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBitfieldGet();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.encoding = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.offset = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            encoding: isSet(object.encoding) ? globalThis.String(object.encoding) : "",
            offset: isSet(object.offset) ? globalThis.String(object.offset) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.encoding !== "") {
            obj.encoding = message.encoding;
        }
        if (message.offset !== "") {
            obj.offset = message.offset;
        }
        return obj;
    },
    create(base) {
        return BitfieldGet.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBitfieldGet();
        message.encoding = object.encoding ?? "";
        message.offset = object.offset ?? "";
        return message;
    },
};
messageTypeRegistry.set(BitfieldGet.$type, BitfieldGet);
function createBaseBitfieldSet() {
    return { encoding: "", offset: "", value: "" };
}
export const BitfieldSet = {
    $type: "devvit.plugin.redis.BitfieldSet",
    encode(message, writer = _m0.Writer.create()) {
        if (message.encoding !== "") {
            writer.uint32(10).string(message.encoding);
        }
        if (message.offset !== "") {
            writer.uint32(18).string(message.offset);
        }
        if (message.value !== "") {
            writer.uint32(26).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBitfieldSet();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.encoding = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.offset = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            encoding: isSet(object.encoding) ? globalThis.String(object.encoding) : "",
            offset: isSet(object.offset) ? globalThis.String(object.offset) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.encoding !== "") {
            obj.encoding = message.encoding;
        }
        if (message.offset !== "") {
            obj.offset = message.offset;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return BitfieldSet.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBitfieldSet();
        message.encoding = object.encoding ?? "";
        message.offset = object.offset ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
messageTypeRegistry.set(BitfieldSet.$type, BitfieldSet);
function createBaseBitfieldIncrBy() {
    return { encoding: "", offset: "", increment: "" };
}
export const BitfieldIncrBy = {
    $type: "devvit.plugin.redis.BitfieldIncrBy",
    encode(message, writer = _m0.Writer.create()) {
        if (message.encoding !== "") {
            writer.uint32(10).string(message.encoding);
        }
        if (message.offset !== "") {
            writer.uint32(18).string(message.offset);
        }
        if (message.increment !== "") {
            writer.uint32(26).string(message.increment);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBitfieldIncrBy();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.encoding = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.offset = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.increment = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            encoding: isSet(object.encoding) ? globalThis.String(object.encoding) : "",
            offset: isSet(object.offset) ? globalThis.String(object.offset) : "",
            increment: isSet(object.increment) ? globalThis.String(object.increment) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.encoding !== "") {
            obj.encoding = message.encoding;
        }
        if (message.offset !== "") {
            obj.offset = message.offset;
        }
        if (message.increment !== "") {
            obj.increment = message.increment;
        }
        return obj;
    },
    create(base) {
        return BitfieldIncrBy.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBitfieldIncrBy();
        message.encoding = object.encoding ?? "";
        message.offset = object.offset ?? "";
        message.increment = object.increment ?? "";
        return message;
    },
};
messageTypeRegistry.set(BitfieldIncrBy.$type, BitfieldIncrBy);
function createBaseBitfieldOverflow() {
    return { behavior: 0 };
}
export const BitfieldOverflow = {
    $type: "devvit.plugin.redis.BitfieldOverflow",
    encode(message, writer = _m0.Writer.create()) {
        if (message.behavior !== 0) {
            writer.uint32(8).int32(message.behavior);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBitfieldOverflow();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.behavior = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { behavior: isSet(object.behavior) ? bitfieldOverflowBehaviorFromJSON(object.behavior) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.behavior !== 0) {
            obj.behavior = bitfieldOverflowBehaviorToJSON(message.behavior);
        }
        return obj;
    },
    create(base) {
        return BitfieldOverflow.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBitfieldOverflow();
        message.behavior = object.behavior ?? 0;
        return message;
    },
};
messageTypeRegistry.set(BitfieldOverflow.$type, BitfieldOverflow);
function createBaseBitfieldResponse() {
    return { results: [] };
}
export const BitfieldResponse = {
    $type: "devvit.plugin.redis.BitfieldResponse",
    encode(message, writer = _m0.Writer.create()) {
        writer.uint32(10).fork();
        for (const v of message.results) {
            writer.int64(v);
        }
        writer.ldelim();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBitfieldResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag === 8) {
                        message.results.push(longToNumber(reader.int64()));
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.results.push(longToNumber(reader.int64()));
                        }
                        continue;
                    }
                    break;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            results: globalThis.Array.isArray(object?.results) ? object.results.map((e) => globalThis.Number(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.results?.length) {
            obj.results = message.results.map((e) => Math.round(e));
        }
        return obj;
    },
    create(base) {
        return BitfieldResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBitfieldResponse();
        message.results = object.results?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set(BitfieldResponse.$type, BitfieldResponse);
function createBaseHSetNXRequest() {
    return { key: "", field: "", value: "", transactionId: undefined, scope: undefined };
}
export const HSetNXRequest = {
    $type: "devvit.plugin.redis.HSetNXRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.field !== "") {
            writer.uint32(18).string(message.field);
        }
        if (message.value !== "") {
            writer.uint32(26).string(message.value);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(34).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHSetNXRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.field = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            field: isSet(object.field) ? globalThis.String(object.field) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.field !== "") {
            obj.field = message.field;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        if (message.transactionId !== undefined) {
            obj.transactionId = TransactionId.toJSON(message.transactionId);
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return HSetNXRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHSetNXRequest();
        message.key = object.key ?? "";
        message.field = object.field ?? "";
        message.value = object.value ?? "";
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(HSetNXRequest.$type, HSetNXRequest);
function createBaseRenameRequest() {
    return { key: "", newKey: "", scope: undefined };
}
export const RenameRequest = {
    $type: "devvit.plugin.redis.RenameRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.newKey !== "") {
            writer.uint32(18).string(message.newKey);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRenameRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.newKey = reader.string();
                    continue;
                case 100:
                    if (tag !== 800) {
                        break;
                    }
                    message.scope = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            newKey: isSet(object.newKey) ? globalThis.String(object.newKey) : "",
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.newKey !== "") {
            obj.newKey = message.newKey;
        }
        if (message.scope !== undefined) {
            obj.scope = redisKeyScopeToJSON(message.scope);
        }
        return obj;
    },
    create(base) {
        return RenameRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRenameRequest();
        message.key = object.key ?? "";
        message.newKey = object.newKey ?? "";
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(RenameRequest.$type, RenameRequest);
function createBaseRenameResponse() {
    return { result: "" };
}
export const RenameResponse = {
    $type: "devvit.plugin.redis.RenameResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.result !== "") {
            writer.uint32(10).string(message.result);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRenameResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.result = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { result: isSet(object.result) ? globalThis.String(object.result) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.result !== "") {
            obj.result = message.result;
        }
        return obj;
    },
    create(base) {
        return RenameResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRenameResponse();
        message.result = object.result ?? "";
        return message;
    },
};
messageTypeRegistry.set(RenameResponse.$type, RenameResponse);
export const RedisAPIServiceName = "devvit.plugin.redis.RedisAPI";
export class RedisAPIClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || RedisAPIServiceName;
        this.rpc = rpc;
        this.Get = this.Get.bind(this);
        this.GetBytes = this.GetBytes.bind(this);
        this.Set = this.Set.bind(this);
        this.Exists = this.Exists.bind(this);
        this.Del = this.Del.bind(this);
        this.Type = this.Type.bind(this);
        this.Rename = this.Rename.bind(this);
        this.IncrBy = this.IncrBy.bind(this);
        this.HSet = this.HSet.bind(this);
        this.HGet = this.HGet.bind(this);
        this.HMGet = this.HMGet.bind(this);
        this.HGetAll = this.HGetAll.bind(this);
        this.HDel = this.HDel.bind(this);
        this.HScan = this.HScan.bind(this);
        this.HKeys = this.HKeys.bind(this);
        this.HIncrBy = this.HIncrBy.bind(this);
        this.HLen = this.HLen.bind(this);
        this.HSetNX = this.HSetNX.bind(this);
        this.Multi = this.Multi.bind(this);
        this.Exec = this.Exec.bind(this);
        this.Discard = this.Discard.bind(this);
        this.Watch = this.Watch.bind(this);
        this.Unwatch = this.Unwatch.bind(this);
        this.GetRange = this.GetRange.bind(this);
        this.SetRange = this.SetRange.bind(this);
        this.Strlen = this.Strlen.bind(this);
        this.MGet = this.MGet.bind(this);
        this.MSet = this.MSet.bind(this);
        this.Expire = this.Expire.bind(this);
        this.ExpireTime = this.ExpireTime.bind(this);
        this.ZAdd = this.ZAdd.bind(this);
        this.ZCard = this.ZCard.bind(this);
        this.ZRange = this.ZRange.bind(this);
        this.ZRem = this.ZRem.bind(this);
        this.ZRemRangeByLex = this.ZRemRangeByLex.bind(this);
        this.ZRemRangeByRank = this.ZRemRangeByRank.bind(this);
        this.ZRemRangeByScore = this.ZRemRangeByScore.bind(this);
        this.ZScore = this.ZScore.bind(this);
        this.ZRank = this.ZRank.bind(this);
        this.ZIncrBy = this.ZIncrBy.bind(this);
        this.ZScan = this.ZScan.bind(this);
        this.Bitfield = this.Bitfield.bind(this);
    }
    Get(request, metadata) {
        const data = KeyRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Get", data, metadata);
        return promise.then((data) => StringValue.decode(_m0.Reader.create(data)));
    }
    GetBytes(request, metadata) {
        const data = KeyRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "GetBytes", data, metadata);
        return promise.then((data) => BytesValue.decode(_m0.Reader.create(data)));
    }
    Set(request, metadata) {
        const data = SetRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Set", data, metadata);
        return promise.then((data) => StringValue.decode(_m0.Reader.create(data)));
    }
    Exists(request, metadata) {
        const data = KeysRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Exists", data, metadata);
        return promise.then((data) => ExistsResponse.decode(_m0.Reader.create(data)));
    }
    Del(request, metadata) {
        const data = KeysRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Del", data, metadata);
        return promise.then((data) => Int64Value.decode(_m0.Reader.create(data)));
    }
    Type(request, metadata) {
        const data = KeyRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Type", data, metadata);
        return promise.then((data) => StringValue.decode(_m0.Reader.create(data)));
    }
    Rename(request, metadata) {
        const data = RenameRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Rename", data, metadata);
        return promise.then((data) => RenameResponse.decode(_m0.Reader.create(data)));
    }
    IncrBy(request, metadata) {
        const data = IncrByRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "IncrBy", data, metadata);
        return promise.then((data) => Int64Value.decode(_m0.Reader.create(data)));
    }
    HSet(request, metadata) {
        const data = HSetRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "HSet", data, metadata);
        return promise.then((data) => Int64Value.decode(_m0.Reader.create(data)));
    }
    HGet(request, metadata) {
        const data = HGetRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "HGet", data, metadata);
        return promise.then((data) => StringValue.decode(_m0.Reader.create(data)));
    }
    HMGet(request, metadata) {
        const data = HMGetRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "HMGet", data, metadata);
        return promise.then((data) => RedisValues.decode(_m0.Reader.create(data)));
    }
    HGetAll(request, metadata) {
        const data = KeyRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "HGetAll", data, metadata);
        return promise.then((data) => RedisFieldValues.decode(_m0.Reader.create(data)));
    }
    HDel(request, metadata) {
        const data = HDelRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "HDel", data, metadata);
        return promise.then((data) => Int64Value.decode(_m0.Reader.create(data)));
    }
    HScan(request, metadata) {
        const data = HScanRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "HScan", data, metadata);
        return promise.then((data) => HScanResponse.decode(_m0.Reader.create(data)));
    }
    HKeys(request, metadata) {
        const data = KeyRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "HKeys", data, metadata);
        return promise.then((data) => KeysResponse.decode(_m0.Reader.create(data)));
    }
    HIncrBy(request, metadata) {
        const data = HIncrByRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "HIncrBy", data, metadata);
        return promise.then((data) => Int64Value.decode(_m0.Reader.create(data)));
    }
    HLen(request, metadata) {
        const data = KeyRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "HLen", data, metadata);
        return promise.then((data) => Int64Value.decode(_m0.Reader.create(data)));
    }
    HSetNX(request, metadata) {
        const data = HSetNXRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "HSetNX", data, metadata);
        return promise.then((data) => HSetNXResponse.decode(_m0.Reader.create(data)));
    }
    Multi(request, metadata) {
        const data = TransactionId.encode(request).finish();
        const promise = this.rpc.request(this.service, "Multi", data, metadata);
        return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
    }
    Exec(request, metadata) {
        const data = TransactionId.encode(request).finish();
        const promise = this.rpc.request(this.service, "Exec", data, metadata);
        return promise.then((data) => TransactionResponses.decode(_m0.Reader.create(data)));
    }
    Discard(request, metadata) {
        const data = TransactionId.encode(request).finish();
        const promise = this.rpc.request(this.service, "Discard", data, metadata);
        return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
    }
    Watch(request, metadata) {
        const data = WatchRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Watch", data, metadata);
        return promise.then((data) => TransactionId.decode(_m0.Reader.create(data)));
    }
    Unwatch(request, metadata) {
        const data = TransactionId.encode(request).finish();
        const promise = this.rpc.request(this.service, "Unwatch", data, metadata);
        return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
    }
    GetRange(request, metadata) {
        const data = KeyRangeRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "GetRange", data, metadata);
        return promise.then((data) => StringValue.decode(_m0.Reader.create(data)));
    }
    SetRange(request, metadata) {
        const data = SetRangeRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "SetRange", data, metadata);
        return promise.then((data) => Int64Value.decode(_m0.Reader.create(data)));
    }
    Strlen(request, metadata) {
        const data = KeyRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Strlen", data, metadata);
        return promise.then((data) => Int64Value.decode(_m0.Reader.create(data)));
    }
    MGet(request, metadata) {
        const data = KeysRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "MGet", data, metadata);
        return promise.then((data) => RedisValues.decode(_m0.Reader.create(data)));
    }
    MSet(request, metadata) {
        const data = KeyValuesRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "MSet", data, metadata);
        return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
    }
    Expire(request, metadata) {
        const data = ExpireRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Expire", data, metadata);
        return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
    }
    ExpireTime(request, metadata) {
        const data = KeyRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ExpireTime", data, metadata);
        return promise.then((data) => Int64Value.decode(_m0.Reader.create(data)));
    }
    ZAdd(request, metadata) {
        const data = ZAddRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZAdd", data, metadata);
        return promise.then((data) => Int64Value.decode(_m0.Reader.create(data)));
    }
    ZCard(request, metadata) {
        const data = KeyRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZCard", data, metadata);
        return promise.then((data) => Int64Value.decode(_m0.Reader.create(data)));
    }
    ZRange(request, metadata) {
        const data = ZRangeRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZRange", data, metadata);
        return promise.then((data) => ZMembers.decode(_m0.Reader.create(data)));
    }
    ZRem(request, metadata) {
        const data = ZRemRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZRem", data, metadata);
        return promise.then((data) => Int64Value.decode(_m0.Reader.create(data)));
    }
    ZRemRangeByLex(request, metadata) {
        const data = ZRemRangeByLexRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZRemRangeByLex", data, metadata);
        return promise.then((data) => Int64Value.decode(_m0.Reader.create(data)));
    }
    ZRemRangeByRank(request, metadata) {
        const data = ZRemRangeByRankRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZRemRangeByRank", data, metadata);
        return promise.then((data) => Int64Value.decode(_m0.Reader.create(data)));
    }
    ZRemRangeByScore(request, metadata) {
        const data = ZRemRangeByScoreRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZRemRangeByScore", data, metadata);
        return promise.then((data) => Int64Value.decode(_m0.Reader.create(data)));
    }
    ZScore(request, metadata) {
        const data = ZScoreRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZScore", data, metadata);
        return promise.then((data) => DoubleValue.decode(_m0.Reader.create(data)));
    }
    ZRank(request, metadata) {
        const data = ZRankRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZRank", data, metadata);
        return promise.then((data) => Int64Value.decode(_m0.Reader.create(data)));
    }
    ZIncrBy(request, metadata) {
        const data = ZIncrByRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZIncrBy", data, metadata);
        return promise.then((data) => DoubleValue.decode(_m0.Reader.create(data)));
    }
    ZScan(request, metadata) {
        const data = ZScanRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZScan", data, metadata);
        return promise.then((data) => ZScanResponse.decode(_m0.Reader.create(data)));
    }
    Bitfield(request, metadata) {
        const data = BitfieldRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Bitfield", data, metadata);
        return promise.then((data) => BitfieldResponse.decode(_m0.Reader.create(data)));
    }
}
export const RedisAPIDefinition = {
    name: "RedisAPI",
    fullName: "devvit.plugin.redis.RedisAPI",
    methods: {
        /** Simple Key-Value operations */
        get: {
            name: "Get",
            requestType: KeyRequest,
            requestStream: false,
            responseType: StringValue,
            responseStream: false,
            options: {},
        },
        getBytes: {
            name: "GetBytes",
            requestType: KeyRequest,
            requestStream: false,
            responseType: BytesValue,
            responseStream: false,
            options: {},
        },
        set: {
            name: "Set",
            requestType: SetRequest,
            requestStream: false,
            responseType: StringValue,
            responseStream: false,
            options: {},
        },
        exists: {
            name: "Exists",
            requestType: KeysRequest,
            requestStream: false,
            responseType: ExistsResponse,
            responseStream: false,
            options: {},
        },
        del: {
            name: "Del",
            requestType: KeysRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        type: {
            name: "Type",
            requestType: KeyRequest,
            requestStream: false,
            responseType: StringValue,
            responseStream: false,
            options: {},
        },
        rename: {
            name: "Rename",
            requestType: RenameRequest,
            requestStream: false,
            responseType: RenameResponse,
            responseStream: false,
            options: {},
        },
        /** Number operations */
        incrBy: {
            name: "IncrBy",
            requestType: IncrByRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        /** Redis Hash operations */
        hSet: {
            name: "HSet",
            requestType: HSetRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        hGet: {
            name: "HGet",
            requestType: HGetRequest,
            requestStream: false,
            responseType: StringValue,
            responseStream: false,
            options: {},
        },
        hMGet: {
            name: "HMGet",
            requestType: HMGetRequest,
            requestStream: false,
            responseType: RedisValues,
            responseStream: false,
            options: {},
        },
        hGetAll: {
            name: "HGetAll",
            requestType: KeyRequest,
            requestStream: false,
            responseType: RedisFieldValues,
            responseStream: false,
            options: {},
        },
        hDel: {
            name: "HDel",
            requestType: HDelRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        hScan: {
            name: "HScan",
            requestType: HScanRequest,
            requestStream: false,
            responseType: HScanResponse,
            responseStream: false,
            options: {},
        },
        hKeys: {
            name: "HKeys",
            requestType: KeyRequest,
            requestStream: false,
            responseType: KeysResponse,
            responseStream: false,
            options: {},
        },
        hIncrBy: {
            name: "HIncrBy",
            requestType: HIncrByRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        hLen: {
            name: "HLen",
            requestType: KeyRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        hSetNX: {
            name: "HSetNX",
            requestType: HSetNXRequest,
            requestStream: false,
            responseType: HSetNXResponse,
            responseStream: false,
            options: {},
        },
        /** Transactions */
        multi: {
            name: "Multi",
            requestType: TransactionId,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        exec: {
            name: "Exec",
            requestType: TransactionId,
            requestStream: false,
            responseType: TransactionResponses,
            responseStream: false,
            options: {},
        },
        discard: {
            name: "Discard",
            requestType: TransactionId,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        watch: {
            name: "Watch",
            requestType: WatchRequest,
            requestStream: false,
            responseType: TransactionId,
            responseStream: false,
            options: {},
        },
        unwatch: {
            name: "Unwatch",
            requestType: TransactionId,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        /** String operations */
        getRange: {
            name: "GetRange",
            requestType: KeyRangeRequest,
            requestStream: false,
            responseType: StringValue,
            responseStream: false,
            options: {},
        },
        setRange: {
            name: "SetRange",
            requestType: SetRangeRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        strlen: {
            name: "Strlen",
            requestType: KeyRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        /** Batch Key-Value operations */
        mGet: {
            name: "MGet",
            requestType: KeysRequest,
            requestStream: false,
            responseType: RedisValues,
            responseStream: false,
            options: {},
        },
        mSet: {
            name: "MSet",
            requestType: KeyValuesRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        /** Key expiration */
        expire: {
            name: "Expire",
            requestType: ExpireRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        expireTime: {
            name: "ExpireTime",
            requestType: KeyRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        /** Sorted sets */
        zAdd: {
            name: "ZAdd",
            requestType: ZAddRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        zCard: {
            name: "ZCard",
            requestType: KeyRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        zRange: {
            name: "ZRange",
            requestType: ZRangeRequest,
            requestStream: false,
            responseType: ZMembers,
            responseStream: false,
            options: {},
        },
        zRem: {
            name: "ZRem",
            requestType: ZRemRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        zRemRangeByLex: {
            name: "ZRemRangeByLex",
            requestType: ZRemRangeByLexRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        zRemRangeByRank: {
            name: "ZRemRangeByRank",
            requestType: ZRemRangeByRankRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        zRemRangeByScore: {
            name: "ZRemRangeByScore",
            requestType: ZRemRangeByScoreRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        zScore: {
            name: "ZScore",
            requestType: ZScoreRequest,
            requestStream: false,
            responseType: DoubleValue,
            responseStream: false,
            options: {},
        },
        zRank: {
            name: "ZRank",
            requestType: ZRankRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        zIncrBy: {
            name: "ZIncrBy",
            requestType: ZIncrByRequest,
            requestStream: false,
            responseType: DoubleValue,
            responseStream: false,
            options: {},
        },
        zScan: {
            name: "ZScan",
            requestType: ZScanRequest,
            requestStream: false,
            responseType: ZScanResponse,
            responseStream: false,
            options: {},
        },
        /** Bitfield */
        bitfield: {
            name: "Bitfield",
            requestType: BitfieldRequest,
            requestStream: false,
            responseType: BitfieldResponse,
            responseStream: false,
            options: {},
        },
    },
};
function longToNumber(long) {
    if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
