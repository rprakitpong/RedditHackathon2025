import type { JSONValue } from '@devvit/shared-types/json.js';
import type { AsyncUseStateInitializer, UseAsyncResult } from '../../../../types/hooks.js';
export type AsyncOptions<S extends JSONValue> = {
    /**
     * The data loader will re-run if the value of `depends` changes.
     */
    depends?: JSONValue;
    /**
     * A callback that will be called after the data is loaded, regardless of whether it succeeds or fails.
     * This is a good place to run setStates or other side effects, because calling a setState in the main
     * body is not allowed.
     *
     *    useAsync(async () => {
     *        const response = await fetch(`https://date.api/today?timezone=${timezone}`);
     *        return response.json();
     *    }, {
     *        depends: [timezone],
     *        finally: (data, error) => {
     *            if (error) {
     *                console.error("Failed to load date data:", error);
     *            } else {
     *                setTodayDate(data['currentDate']);
     *            }
     *        },
     *    });
     *
     */
    finally?: (data: S | null, error: Error | null) => void;
};
export type LoadState = 'initial' | 'loading' | 'loaded' | 'error';
/**
 * This tries to save an error into the state.  If the error is a circuit breaker, it will throw the error instead,
 * as those errors are not meant to be saved in state.
 *
 * @param e  -- an original error type
 * @returns A JSONValue that can be saved in states
 */
export declare function toSerializableErrorOrCircuitBreak(e: unknown): {
    message: string;
    details: string;
};
/**
 * This is the preferred way to handle async state in Devvit.
 *
 * @param initializer -- any async function that returns a JSONValue
 * @returns UseAsyncResult<S>
 */
export declare function useAsync<S extends JSONValue>(initializer: AsyncUseStateInitializer<S>, options?: AsyncOptions<S>): UseAsyncResult<S>;
//# sourceMappingURL=useAsync.d.ts.map